# VRP Solver v2 — 開發說明

## 設計目標

在不改動 v1 的前提下，解決三個最常造成「求解直接失敗」或「無法表達真實業務需求」的問題：

1. **軟性時間窗**：時間窗緊張時 v1 直接報錯，v2 允許遲到但計罰金
2. **可選地點**：v1 所有地點必訪，v2 允許跳過（付代價）
3. **路線時長上限**：v2 可表達「司機最多工作 N 小時」

所有新欄位預設為 `None`，v2 在行為上完全向下相容 v1 payload。

---

## 架構決策

### 為何繼承 schema 而非另起爐灶？

```python
class LocationV2(Location):
    unserved_penalty: int | None = None
    late_penalty: int | None = None
```

Pydantic 的繼承讓 v2 schema 複用所有 v1 欄位驗證邏輯，不重複維護。`VRPRequestV2` 只需覆寫 `locations` 和 `vehicles` 的型別，其餘欄位（`distance_matrix`、`time_matrix` 等）全部繼承。

### 軟性時間窗：`SetCumulVarSoftUpperBound`

v1 使用 `CumulVar(index).SetRange(start, end)` — 硬性上下界，超出 → infeasible。

v2 的處理：

```python
# 硬性下界保留（不能早到）
time_dimension.CumulVar(index).SetRange(start, max_time)
# 軟性上界：超過 end 每分鐘罰 late_penalty
time_dimension.SetCumulVarSoftUpperBound(index, end, late_penalty)
```

**為何下界仍是硬性的？** 早到可以等，這在業務上通常是可接受的；但提早到達並沒有「罰金」的概念（提早到只是浪費時間，solver 會自然最小化）。因此不需要 `SetCumulVarSoftLowerBound`。

### 可選地點：`AddDisjunction`

```python
routing.AddDisjunction([index], penalty)
```

OR-Tools 的 `AddDisjunction` 接受一組節點，solver 可以選擇「全部跳過，但支付 penalty」。這裡每個可選地點各自獨立呼叫，penalty 即為 `unserved_penalty`。

**penalty 的單位與 arc cost 相同（公尺）。** 實際使用時，`unserved_penalty` 需要設定得比「繞路去該地點的距離成本」大，solver 才會選擇拜訪。這個數字的設定是業務決策，不是技術決策——文件應清楚說明。

**必訪地點（`unserved_penalty = None`）不呼叫 `AddDisjunction`**，OR-Tools 預設所有未加 Disjunction 的節點都必須服務，v1 行為自然保留。

### 路線時長上限：`CumulVar(End(v)).SetMax`

```python
time_dimension.CumulVar(routing.End(v_idx)).SetMax(max_duration_minutes)
```

Time dimension 的 CumulVar 在 End 節點代表「車輛完成所有停靠並返回 depot 的時間」，直接 `SetMax` 是最簡單的表達方式。這是硬性約束——超過就 infeasible，不提供 soft 版本（業務上工時上限通常是法規或合約要求，不應軟化）。

### `add_optional_stops` 在時間維度之後呼叫

順序重要：`AddDisjunction` 必須在所有 dimension 設定完成後呼叫，否則 OR-Tools 內部的節點狀態可能不一致。目前在 `engine.py` 中的呼叫順序：

```
add_time_dimension_v2 → add_optional_stops → add_max_duration
```

### `result.py` 的 `unserved_locations` 收集方式

```python
served_location_ids = {stop["location_id"] for route in routes for stop in route["stops"]}
unserved = [loc for i, loc in enumerate(data.locations)
            if i != data.depot_index and loc.id not in served_location_ids]
```

這裡比對的是 `location.id`（業務 ID），而不是 index。原因：depot 會出現在每條路線的起點和終點，若用 index 比對會產生誤判。

---

## 已知限制

| 限制 | 說明 |
|---|---|
| `unserved_penalty` 單位不直覺 | 使用者需理解「penalty 要大於繞路距離（公尺）才有效」，容易設錯 |
| 軟性時間窗無下界懲罰 | 早到等待不計罰，某些業務場景（如客戶拒絕太早送達）無法表達 |
| `max_duration_minutes` 是硬性約束 | 若所有地點必訪但總時長超過車輛上限，solver 直接失敗而非降級 |
| 單一 depot、無配對取送 | 繼承自 v1，未在 v2 解決 |

---

## 可改善方向

### 1. `unserved_penalty` 的標準化輔助
提供一個 helper 或文件說明如何估算合理的 `unserved_penalty`，例如「設為該地點到最近鄰居距離的 1.5 倍」作為起點。

### 2. Soft `max_duration`
目前是硬性上限。可考慮提供 `max_duration_penalty_per_minute` 欄位，讓 solver 在超時時計罰而非直接失敗，與軟性時間窗的設計對稱。

### 3. 同時設 `unserved_penalty` 與 `late_penalty` 的互動
若一個地點同時設定了兩者，solver 可能選擇「訪問但遲到（付 late_penalty）」或「不訪問（付 unserved_penalty）」，兩者競爭。這個行為是正確的，但應在文件或 API 說明中明確告知使用者。

### 4. v3 方向：多 depot
需要重構 `RoutingIndexManager` 的初始化方式，從 `(N, V, depot_index)` 改為 `(N, V, starts, ends)`，其中 `starts` 和 `ends` 是每輛車的起終點 index 陣列。這個改動會影響 schema、engine、constraints 各層，建議獨立為 v3 而非在 v2 上修改。
