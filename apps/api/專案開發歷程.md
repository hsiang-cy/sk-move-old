# apps/api — 專案開發歷程

本文件記錄 `apps/api`（Cloudflare Workers + GraphQL）從零開始到現在的決策脈絡，供後續接手人員理解為何現在長這樣。

---

## 背景：為何這個 app 存在

專案最初（`first commit`, 2026-02-20）同時存在兩個後端：

- `apps/backend`：完整的 REST API，使用 Hono + OpenAPI + TypeBox 做 schema 驗證，以 Cloudflare Workers 部署。
- `apps/api`：當時只是空殼，只有一個 `src/index.ts` 回傳 Hello World。

`apps/backend` 是較早的原型，已有完整 DB schema（Drizzle + Neon），但用 REST + TypeBox 維護型別驗證較繁瑣。`apps/api` 定位是「用 GraphQL 重寫」的新版本。

最終在 2026-02-22（`rm "backend dir"` commit）徹底移除 `apps/backend`，全面改用 `apps/api`。

---

## 階段一：DB 連線與 GraphQL 初始化（2026-02-20）

**commits:** `27289ca` → `455d4cf` → `a5768bc`

### DB Schema 建立（27289ca）

`apps/api` 開始有實質內容：建立 Drizzle ORM 設定、Neon serverless PostgreSQL 連線、完整 DB schema（`src/db/schema.ts`），並執行第一次 migration（`0000_cloudy_makkari.sql`）。

Schema 設計了業務的核心實體：`account`、`destination`（配送地點）、`vehicle`（車輛）、`order`（訂單）、`compute`（計算任務）、`route` / `route_stop`（路線結果）、`info_between_two_point`（地點間距離/時間矩陣快取）。

### GraphQL 初始化（455d4cf）

引入 GraphQL Yoga，`src/index.ts` 掛載 `/graphql` 端點。初版 schema 是單一大檔案（`src/graphql/schema.ts`）。

### Cloudflare Workers 冷啟動問題（a5768bc）

Workers 有冷啟動限制：在 `fetch` handler 外不能執行非同步初始化。這次 commit 調整了初始化邏輯，將 DB 連線改為 lazy initialization（收到第一個 request 才建立），避免 Worker 啟動失敗。

---

## 階段二：GraphQL 登入與測試（2026-02-21）

**commits:** `b2bbfc4` → `a822a00`

### GraphQL Login（b2bbfc4）

實作帳號登入的 GraphQL mutation，JWT 簽發。同時建立 `apps/api/GEMINI.md`（當時借助 Gemini 輔助開發，後來在 `b1c9ea3` 中移除）。

### 嘗試串接 Modal（a822a00）

測試從 API 端呼叫 OR-Tools Modal 服務。這時 OR-Tools 的 job_id 還是 UUID，API 端沒有對應機制追蹤，因此「觸發計算 → 收到結果」的流程尚未打通。主要是確認網路可通。

---

## 階段三：完整 GraphQL Schema 與刪除舊 Backend（2026-02-22）

**commits:** `290f7c5` → `e55b67d` → `b876c09` → `014b478`

### DB Schema 微調（290f7c5）

在確立 GraphQL 路線後重新審視 schema，做細節調整後重新 migrate。

### 刪除 apps/backend（e55b67d）

`apps/backend`（REST 版本）正式刪除，REST → GraphQL 的轉換完成。

### 全面 GraphQL（b876c09）

這是里程碑 commit：一次建立所有 resolver 檔案：
- `src/graphql/context.ts` — Context 型別、`requireAuth()` helper（角色: `just_view < guest < normal < manager < admin`）
- `src/graphql/resolvers/account.ts` — 登入、建立帳號
- `src/graphql/resolvers/destination.ts` — CRUD，含 JSONB `data` 欄位（`is_depot`, `time_window`, `operation_time`, `demand`, `priority`）
- `src/graphql/resolvers/vehicle.ts` — CRUD，含 `custom_vehicle_type` 關聯
- `src/graphql/resolvers/order.ts` — 建立訂單，對 destination/vehicle 建立 snapshot（防止後續資料異動影響歷史計算）
- `src/graphql/resolvers/compute.ts` — 建立計算任務（當時尚未真正觸發 OR-Tools）
- `apps/api/test_api.py` — Python 測試腳本
- `apps/api/使用說明.md` — 完整 API 使用文件（已在後續 commit 移除）

同時建立了 `apps/api/今日計畫.md`（記錄當天開發計劃，後來移除）。

### Resolver 拆分（014b478）

原本所有型別定義和 resolver 邏輯全擠在 `schema.ts`（一個超大檔案）。這次把 `typeDefs` 和 `resolvers` 拆到各自的 domain 檔案，`schema.ts` 只負責 merge，可維護性大幅提升。

---

## 階段四：串接 OR-Tools 完整非同步流程（2026-02-24）

**commits:** `78614b7`

這是最關鍵的整合 commit。詳細決策過程記錄在根目錄 `開發日誌.md` Day 1。

### 為何用 REST 而不是 GraphQL 做 webhook

OR-Tools 端只是 `httpx.post(url, json=payload)`，如果做 GraphQL mutation 需要 Python 端構造 mutation 字串，沒有意義。Server-to-server webhook 用 shared secret header 驗證最自然。

### 身份識別改為 compute_id

OR-Tools 原本自己產生 UUID 作為 `job_id`，API 端無法對應。改為由 API 建立 compute 記錄後把 `compute_id`（整數 PK）帶進 VRP 請求，OR-Tools 全程使用這個 ID 回傳，兩端以同一整數對應。

### 矩陣查詢

距離矩陣與時間矩陣從 `info_between_two_point` 資料表動態組裝（以 destination ID 為 key 建 N×N 矩陣）。若資料不完整，直接將 compute 標記為 `failed`。

### webhook receiver（src/routes/webhook.ts）

`POST /internal/vrp-callback`：
- 驗證 `X-Webhook-Secret`（選填，避免公開 endpoint 被濫用）
- `status: error` → 寫入 `fail_reason`，更新 compute 狀態
- `status: success` → 寫入 `route` + `route_stop` 表，更新 compute 狀態

### TypeScript 型別問題修復

`ORTOOLS_WEBHOOK_SECRET` 在 `Bindings`（Workers 環境變數型別）是 `string`（必填），但 `Context.env` 沒有這個欄位，GraphQL Yoga 型別推導衝突。解法：改為 `ORTOOLS_WEBHOOK_SECRET?: string`（optional），符合「不設定也能運作」的業務語意。

---

## 階段五：DB Schema 補強與 Google Routes API（2026-02-26）

**commits:** `7046c15` → `ad1d4c0` → `5277762` → `7d95ef9`

### 新增欄位（7046c15）

- `order` 表新增 `algorithm` 欄位（記錄使用哪個 VRP solver 版本，v1/v2），因為 DB 已有資料，給了 default 值
- 新增 `point_log` 表（帳號積分紀錄，`account` 上加鎖更新）
- 新增 `token` 表（管理 API token）

### Google Routes API 整合（5277762）

`createOrder` resolver 擴充：
1. 先查 `info_between_two_point` 是否已有快取
2. 缺少的地點對才呼叫 Google Routes API 取得距離/時間
3. 新資料寫入 `info_between_two_point` 供後續使用

這解決了「距離矩陣需要人工填入」的問題，訂單建立時自動補全。

---

## 架構現狀摘要

```
apps/api/
├── src/
│   ├── index.ts              # Hono entry; mounts /graphql
│   ├── db/
│   │   ├── schema.ts         # 所有 table 定義（唯一真相來源）
│   │   └── connect.ts        # Neon HTTP client
│   ├── graphql/
│   │   ├── schema.ts         # 合併所有 typeDefs + resolvers
│   │   ├── context.ts        # Context 型別 + requireAuth()
│   │   └── resolvers/        # 一個 domain 一個檔案
│   └── routes/
│       └── webhook.ts        # POST /internal/vrp-callback
└── migrations-folder/        # Drizzle 生成的 SQL migrations
```

---

## 未完成事項（截至 2026-02-26）

- `info_between_two_point` 的填充機制（已在 `createOrder` 階段完成，但 `createCompute` 若矩陣不完整仍會失敗）
- `ORTOOLS_WEBHOOK_SECRET` 正式環境設定（`wrangler secret put`）
- 計算狀態輪詢：前端目前需手動重新整理才能看到 pending → completed
- `destination_snapshot` / `vehicle_snapshot` 格式規範化
