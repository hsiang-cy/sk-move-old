# apps/ortools — 專案開發歷程

本文件記錄 `apps/ortools`（Python + Modal + OR-Tools VRP Solver）從零開始到現在的決策脈絡，供後續接手人員理解為何現在長這樣。

---

## 背景：為何獨立成一個服務

VRP（Vehicle Routing Problem）求解需要：
1. **大量 CPU/Memory**：OR-Tools 的 GLS metaheuristic 在大規模問題（> 50 地點）可能吃掉數 GB RAM 和數分鐘 CPU 時間
2. **Python 生態**：OR-Tools 官方只有 Python / C++ binding，TypeScript 沒有對等支援
3. **按需啟動**：計算任務不頻繁，不需要長駐伺服器

因此選擇 **Modal**（Python serverless）獨立部署，API 端只需要 `fetch` 一個 REST 端點，不需要管理 Python 環境。

---

## 階段一：單體原型（2026-02-20）

**commit:** `first commit` (fa30571)

### 初始結構

```
apps/ortools/src/
├── index.py          # FastAPI app 入口（包含 /vrp/solve 路由）
├── vrp_solver.py     # OR-Tools 求解邏輯
└── consumer/
    └── compute.py    # 另一個更複雜的求解嘗試
```

這時候的設計是「所有東西放在一起」，`index.py` 同時是 FastAPI app 和業務邏輯。

### 重構：拆分模組（297e9d3）

同一天的第二個 commit，把 VRP 相關邏輯拆出成獨立模組：

```
src/
├── main.py           # FastAPI app（薄薄一層，只掛路由）
└── vrp/
    ├── router.py     # FastAPI router：POST /vrp/solve
    ├── schema.py     # Pydantic 資料模型
    └── solver.py     # OR-Tools 求解邏輯
```

`consumer/compute.py` 也在這次移除，整體結構清晰很多。

---

## 階段二：VRP 功能強化（2026-02-20）

**commit:** `feat(vrp): 支援混合裝卸貨與異質車隊固定成本` (67b1df1)

### 問題：純卸貨情境無解

原版 `Location.demand` 是單一整數（需求量），`Capacity Dimension` 的 `fix_start_cumul_to_zero=True`（車輛從 0 出發）。

但在「純卸貨」情境（所有地點都是 delivery），車輛出發時需要帶著貨，初始載重不是 0。強制從 0 出發導致 infeasible。

**修復**：
- `demand` 拆為 `pickup`（裝貨）和 `delivery`（卸貨）
- `Capacity Dimension` 改為 `fix_start_cumul_to_zero=False`，讓 solver 自動決定初始載重
- 容量約束計算改為淨值：`net_demand = pickup - delivery`

### 問題：固定成本混入距離計算

原版固定成本（鼓勵少用車輛）用全車隊共用的 `fixed_vehicle_cost` 設定。路線距離計算用 `GetArcCostForVehicle`，但這個函式會把 arc cost（距離 + 固定成本）一起回傳，導致路線總距離數值錯誤。

**修復**：
- 每輛車改為 per-vehicle `fixed_cost`（各自設定，更靈活）
- 路線距離改為直接查 `distance_matrix[from][to]` 累加，不用 `GetArcCostForVehicle`

---

## 階段三：Modal Serverless 部署（2026-02-21）

**commits:** `a822a00` → `4a25840`

### 為何選 Modal 而非 AWS Lambda / GCP Cloud Run

| 考量 | Modal |
|---|---|
| 冷啟動 | 有 container 快取，比 Lambda 快 |
| Python 依賴 | `Image.debian_slim().pip_install(...)` 一行搞定，不用打包 Docker |
| 橫向擴展 | 每個請求自動 spawn 新 container，天然 stateless |
| 費用 | 按 CPU 秒計費，零請求零費用 |
| 開發體驗 | `modal serve`（hot reload）、`modal deploy`（一行部署）|

### Fire-and-Forget 架構決策

`POST /vrp/solve` 收到請求後：
1. 立即回傳 `202 Accepted`（不等計算完成）
2. 用 `solve_vrp.spawn.aio()` 在 Modal 背景 container 執行求解
3. 求解完成後，solver 自己 `httpx.post(webhook_url, json=result)`

**為何不用 polling（輪詢）**：
- OR-Tools 求解可能需要數十秒，HTTP 請求 hold 住不釋放會佔用 API server 資源
- 呼叫方（`apps/api`）是 Cloudflare Workers，有 CPU 時間限制，不能長時間等待

### local_dev.py

Modal 的 `spawn.aio()` 在本地不可用（需要 Modal infra）。`local_dev.py` 用 `asyncio.create_task` + `run_in_executor` 替換，讓本地測試不需要 Modal 帳號。

---

## 階段四：API 串接協議確立（2026-02-24）

**commit:** `[api] 串接演算法` (78614b7)

此 commit 同時修改了 `apps/api` 和 `apps/ortools`，是兩個服務的整合點。

### job_id → compute_id

原本 OR-Tools 自己產生 UUID `job_id`，API 端完全不知道這個 ID，webhook 回呼時無法對應 DB 記錄。

**解法**：改為 **API 端主導身份識別**：
- API 先在 DB 建立 `compute` 記錄，取得整數 PK（`compute_id`）
- 把 `compute_id` 帶入 VRP request body
- OR-Tools 在 webhook payload 回傳同一個 `compute_id`
- API 端根據 `compute_id` 找到 DB 記錄並更新

這個改動讓兩端用「同一個整數 ID」對齊，比 UUID 更簡單。

### 工具鏈遷移：pip → uv（2c80a04）

同日另一個 commit，把 Python 依賴管理從 `requirements.txt` 改為 **uv**（`pyproject.toml`）：
- `uv sync` 比 `pip install` 快 10-100 倍
- lockfile（`uv.lock`）確保環境可重現
- `[dependency-groups].dev` 區分開發依賴（`modal`）和 runtime 依賴

---

## 階段五：重大架構重構 — Solver 模組化（2026-02-25）

**commit:** `move` (b1c9ea3)

### 重構動機

到這時，`src/vrp/solver.py` 是一個約 200 行的大函式，所有約束邏輯（距離成本、容量、時間窗、固定成本）都混在一起。要新增 v2 功能時，修改這個檔案風險很高，且 v1 / v2 會互相干擾。

### 重構結果

```
src/vrp/
├── api/
│   ├── router.py              # v1 路由（POST /vrp/solve）
│   └── router_v2.py           # v2 路由（POST /vrp/v2/solve）
├── models/
│   ├── schema.py              # v1 Pydantic models
│   └── schema_v2.py           # v2 Pydantic models（繼承 v1）
└── solvers/
    ├── ortools/               # v1 solver
    │   ├── engine.py          # 串接各約束函式，呼叫 solver
    │   ├── constraints.py     # 各約束函式（距離、容量、時間窗、固定成本）
    │   └── result.py          # 解析 OR-Tools solution → webhook payload
    └── ortools_v2/            # v2 solver
        ├── engine.py
        ├── constraints.py
        └── result.py
```

**設計原則**：
- `engine.py` 只負責「按正確順序呼叫約束函式、執行 solver、取得結果」
- `constraints.py` 每個函式對應一個約束，獨立可測試
- `result.py` 只負責把 OR-Tools solution 轉成 JSON

**v2 schema 用繼承**：

```python
class LocationV2(Location):
    unserved_penalty: int | None = None
    late_penalty: int | None = None
```

所有新欄位預設 `None`，v2 完全向下相容 v1 payload。

---

## 階段六：v2 Solver — 三個新功能（2026-02-25）

**commit:** `[ortools] v2` (1ec7e23)

v1 有三個已知會造成「求解直接失敗」的限制（記錄在 `待改進.md`），v2 逐一解決：

### Feature 3：軟性時間窗（Soft Time Window）

v1：`CumulVar(index).SetRange(start, end)` — 硬性上下界，任一節點超出 → 整個問題 infeasible，直接報錯。

v2：
```python
# 硬性下界保留（不能早到但可以等）
time_dimension.CumulVar(index).SetRange(start, max_time)
# 軟性上界：超過 end 每分鐘罰 late_penalty
time_dimension.SetCumulVarSoftUpperBound(index, end, late_penalty)
```

**為何下界仍是硬性**：早到可以等，業務上沒有「太早到需要罰款」的概念。

### Feature 4：可選地點（Optional Stops）

v1：所有地點必訪，無法表達「送不完的明天再說」。

v2：`AddDisjunction([node_index], penalty)` — solver 可選擇「跳過這個地點，支付 penalty（公尺單位）」。

penalty 的設定是業務決策：penalty 要大於「繞路去該地點的距離成本」，solver 才會選擇拜訪而不是跳過。

**必訪地點（`unserved_penalty = None`）不呼叫 `AddDisjunction`**，OR-Tools 預設未加 Disjunction 的節點必訪，v1 行為自然保留。

### Feature 5：路線時長上限（Max Route Duration）

v1：無法限制「司機最多工作 N 小時」。

v2：
```python
time_dimension.CumulVar(routing.End(v_idx)).SetMax(max_duration_minutes)
```

Time dimension CumulVar 在 End 節點代表車輛完成所有停靠並返回 depot 的時間，直接 `SetMax` 是最簡單的表達方式。這是硬性約束（工時上限通常是法規或合約要求，不應軟化）。

### 呼叫順序的重要性

```python
# engine.py 呼叫順序（不能亂）
add_time_dimension_v2(...)
add_optional_stops(...)   # AddDisjunction 必須在所有 dimension 設定完後呼叫
add_max_duration(...)
```

---

## 階段七：v2 補丁 — Feature 6 與 Bug 修復（2026-02-26）

**commit:** `[ortools] v2 dev` (3dbb218)

### Feature 6：車輛與地點匹配限制

新需求：「冷藏車才能去生鮮配送點」。

```python
class LocationV2(Location):
    allowed_vehicle_ids: list[int] | None = None
    # None = 所有車皆可造訪
```

新約束函式 `add_vehicle_constraints`：對每個有 `allowed_vehicle_ids` 的地點，計算禁止造訪的車輛集合，用 `routing.solver().Add(VehicleVar(node) != forbidden_v_idx)` 加入約束。

### Bug：`VehicleVar.RemoveValue()` 在複合約束下被繞過

**現象**：初版用 `routing.VehicleVar(node_index).RemoveValue(v_idx)` 移除禁止的車輛值。單一約束測試通過，但與 `AddDisjunction`、soft TW、`SetMax` 同時啟用時，solver 無視這個約束。

**根本原因**：
- `RemoveValue()` 直接修改 IntVar 的 domain，在 OR-Tools 的 GLS 搜尋中，多重約束共存時傳播不保證執行
- 第一次測試「通過」是因為 capacity 本身就迫使用兩台車，constraint 只是碰巧和最優解吻合，沒有被真正考驗

**修復**：
```python
# 修復前（不可靠）
routing.VehicleVar(node_index).RemoveValue(v_idx)

# 修復後（走 CP propagation engine，與其他約束對等）
routing.solver().Add(routing.VehicleVar(node_index) != v_idx)
```

`routing.solver().Add()` 是 OR-Tools 加入正式約束的標準方式，與 dimension、disjunction 優先順序對等，不會被繞過。

### 計算耗時回傳（elapsed_seconds）

**問題**：使用者收到 webhook 結果時不知道計算花了多久。

**為何不用 FastAPI Middleware**：Middleware 計時是「收到請求 → 回傳 202」（幾乎 0 秒），實際 OR-Tools 求解在 Modal 背景任務中，Middleware 看不到。

**修復**：在 `solve_vrp_logic()` / `solve_vrp_v2_logic()` 內部用 `time.perf_counter()` 計時，加入 webhook payload：

```json
{ "compute_id": 1, "elapsed_seconds": 2.847, "status": "success", ... }
```

---

## 架構現狀摘要

```
apps/ortools/src/
├── main.py                     # Modal App；cpu=1.0, memory=2048MB
├── local_dev.py                # 本地開發替換 Modal spawn
└── vrp/
    ├── api/
    │   ├── router.py           # POST /vrp/solve (v1)
    │   └── router_v2.py        # POST /vrp/v2/solve (v2)
    ├── models/
    │   ├── schema.py           # v1 Pydantic models
    │   └── schema_v2.py        # v2：繼承 v1，新增 optional 欄位
    └── solvers/
        ├── ortools/            # v1 solver
        │   ├── engine.py
        │   ├── constraints.py
        │   ├── result.py
        │   └── 開發說明.md
        └── ortools_v2/         # v2 solver
            ├── engine.py
            ├── constraints.py
            ├── result.py
            └── 開發說明.md
```

---

## v1 vs v2 功能對比

| 功能 | v1 | v2 |
|---|---|---|
| 距離成本 | ✅ | ✅ |
| 容量限制（pickup/delivery） | ✅ | ✅ |
| 時間窗 | 硬性（infeasible → 失敗） | 軟性（遲到付罰金）|
| 所有地點必訪 | ✅（強制） | 可選（付 penalty 可跳過）|
| 車輛固定成本 | ✅ | ✅ |
| 路線時長上限 | ❌ | ✅ |
| 車輛-地點匹配 | ❌ | ✅ |
| 計算耗時回傳 | ✅（後補） | ✅ |

---

## 已規劃但未實作的功能

詳見 `待改進.md`：

- **v3 - 多 depot**：需要重構 `RoutingIndexManager(N, V, depot_index)` → `(N, V, starts, ends)`，影響 schema/engine/constraints/result 全層，建議獨立為 v3
- **v3 - 配對式取送（Pickup-and-Delivery Pairs）**：`AddPickupAndDelivery(pickup_idx, delivery_idx)` + 時間約束，與多 depot 一起做（都需要重構 RoutingIndexManager）
- Webhook 失敗重試（目前只印 log，不 retry）
- `time_limit_seconds` 動態建議值（目前固定 30 秒，小問題浪費，大問題不夠）
