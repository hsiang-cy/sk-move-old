# Day 1 — 2026-02-24

## 目標

讓後端（`apps/api`）能夠串接演算法服務（`apps/ortools`），完成「使用者觸發計算 → 演算法求解 → 結果寫回資料庫」的完整非同步流程。

---

## 規劃

### 串接方式評估：GraphQL vs REST

演算法服務已經是 REST（`POST /vrp/solve`），所以「API → OR-Tools」這段沒有選擇空間，直接用 `fetch`。唯一需要決定的是 OR-Tools 把結果推回來的 **webhook receiver** 要用哪種協議。

結論選 **REST**，理由：
- OR-Tools 端只是單純 `httpx.post(url, json=payload)`，若用 GraphQL 需要讓 Python 端構造 mutation 字串，毫無意義
- Webhook 是 server-to-server，驗證用 shared secret header 最自然
- Hono 加一條 route 極輕量

### 身份識別問題

OR-Tools 原本自己產生 UUID 作為 `job_id`，但 API 端並不知道這個 UUID，導致 webhook 回呼時無法對應到資料庫的 compute 記錄。

規劃改為**以後端為主**：由後端建立 compute 記錄後，把 `compute_id`（整數）帶入請求 body，OR-Tools 全程使用這個 ID，webhook payload 也回傳 `compute_id`，兩端以同一個整數 ID 對應。

### 矩陣來源

距離矩陣與時間矩陣從資料庫的 `info_between_two_point` 表動態查詢，以 destination ID 為 key 組成 N×N 矩陣。若資料不完整則直接將 compute 標記為 `failed`。

---

## 執行過程

### 1. OR-Tools 端改用 `compute_id`

- `vrp/schema.py`：`VRPRequest` 新增 `compute_id: int`
- `vrp/router.py`：移除 `import uuid` 與 UUID 生成，改從 request body 讀取
- `vrp/solver.py`：函式簽名 `job_id: str` → `compute_id: int`，webhook payload key 同步更新
- `main.py` / `local_dev.py`：同步更新

### 2. 後端新增環境變數

`Context.env` 與 `Bindings` 加入：
- `ORTOOLS_URL` — 演算法服務的 base URL
- `API_BASE_URL` — API 自己的 URL（用於組 webhook_url）
- `ORTOOLS_WEBHOOK_SECRET?` — 可選的 shared secret（optional，避免破壞型別相容）

### 3. 更新 `createCompute` resolver

流程：
1. 建立 compute 記錄，初始狀態 `pending`
2. 讀取 order 的 `destination_snapshot` / `vehicle_snapshot`
3. 以 destination ID 查 `info_between_two_point`，組 N×N 距離/時間矩陣
4. 組裝 `VRPRequest` payload（含 `compute_id`、`webhook_url`）
5. `await fetch` POST 到 OR-Tools（只等 202 確認，不等計算完成）
6. 任何失敗點都把 compute 標記為 `failed` 並附上原因

### 4. 新增 `POST /internal/vrp-callback`

新增 `src/routes/webhook.ts`，接收 OR-Tools 的非同步回呼：
- 驗證 `X-Webhook-Secret`（若有設定）
- `status: error` → 更新 `compute_status = failed`，寫入 `fail_reason`
- `status: success` → 逐 route 寫入 `route` 表，再批次寫入 `route_stop`，最後更新 `compute_status = completed`

---

## 遇到的問題

**TypeScript 型別衝突**

`index.ts` 的 `Bindings` 包含 `ORTOOLS_WEBHOOK_SECRET: string`（必填），但 `context.ts` 的 `Context.env` 沒有這個欄位。GraphQL Yoga 在型別推導時要求兩者相容，導致 tsc 報錯。

解法：`ORTOOLS_WEBHOOK_SECRET` 改為 optional（`ORTOOLS_WEBHOOK_SECRET?: string`），符合「不設定也能運作」的業務語意，型別問題同時解決。

---

## 接下來的目標

- [ ] 前端串接：`createCompute` mutation 呼叫，顯示計算狀態（pending → completed）
- [ ] `info_between_two_point` 資料的填充機制：地點建立後如何自動計算並寫入距離矩陣（串接地圖 API）
- [ ] `destination_snapshot` / `vehicle_snapshot` 的格式規範化：目前依賴 client 傳入正確欄位，考慮在 `createOrder` resolver 側做資料正規化
- [ ] 本地端對 webhook 流程做完整 E2E 測試（`local_dev.py` + `wrangler dev`）
- [ ] `ORTOOLS_WEBHOOK_SECRET` 正式環境設定（`wrangler secret put`）

---


# Day 2 — 2026-02-24

## 目標

後端與演算法 MVP 已完成。本日目標為完善前端，讓「建立訂單 → 觸發計算 → 查看路線結果」的完整流程在 UI 上可操作。

---

## 規劃

### 清理 Kiro 的遺留問題

Kiro 自動生成了 orders 相關的前端程式碼，但有幾個明顯問題需要先處理：

- `services/__verification__.md`：Kiro 的 process artifact，不應提交進 repo
- `OrderDetailModal.tsx` / `OrdersView.tsx`：`goToComputes()` 是空殼（只有 `console.log`），`formatTimestamp` 在兩個元件中各自重複定義
- `services/orders.ts` / `services/computes.ts`：存在 `type ApiOrder = Order` 這種無意義的 type alias
- `OrdersView.tsx`：import 了 `useLocations` / `useVehicles`，但這兩個 hook 只在 OrderFormModal 內部用，不應該由 View 層持有

### Computes 頁面設計決策

- **路線結果呈現**：純列表（每條路線一個 section），表格顯示停靠點序號、地點名稱、地址、到達時間、需求量。捨棄地圖視覺化（MVP 不需要）
- **Computes 導航**：Sidebar 新增獨立入口；同時可從訂單列表的操作欄「前往計算」按鈕帶著 `orderId` 跳轉並自動篩選
- **search param 驗證**：`validateSearch` 使用 TanStack Router 原生的 plain function validator，避免引入 zod 依賴（專案本身未安裝）

---

## 執行過程

### 1. 清理

- 刪除 `apps/web/src/services/__verification__.md`
- `apps/web/src/lib/utils.ts` 新增 `formatTimestamp(timestamp, options?)`，統一處理 Unix timestamp → `zh-TW` 格式字串
- `OrderDetailModal.tsx`：改用 `formatTimestamp` from utils，`goToComputes()` 實作為 `navigate({ to: '/computes', search: { orderId: order.id } })`
- `OrdersView.tsx`：同步清理，移除 `useLocations` / `useVehicles` import，`goToComputes()` 同樣實作真正導航
- `services/orders.ts` / `services/computes.ts`：刪除無用 type alias

### 2. Sidebar 導航

`AppSidebar.tsx` 新增兩個 nav item：
- `ClipboardList` icon → `/orders`（訂單管理）
- `Cpu` icon → `/computes`（計算任務）

### 3. Computes 頁面

新建四個檔案：

**`routes/_auth.computes.tsx`**：定義路由，`validateSearch` 解析可選的 `orderId` query param。

**`views/ComputesView.tsx`**：
- 從 URL search param 讀取 `orderId`，有值時顯示篩選 banner（含清除按鈕）
- Table 欄位：計算 ID、訂單 ID、狀態（badge）、建立時間、耗時（`end_time - start_time`，格式化為 `mm分ss秒`）、操作
- `pending` / `computing` 狀態：badge 加上 loading dots 動畫；操作欄顯示取消按鈕
- `completed`：操作欄顯示「查看路線」按鈕，開啟 RouteListModal
- `failed`：操作欄顯示 warning icon，tooltip 顯示 `fail_reason`

**`components/computes/ComputeFormModal.tsx`**：
- `useOrders()` 取得訂單列表作為 `<select>` 選項
- 若從訂單頁面跳轉而來，`defaultOrderId` 預設選中
- 呼叫 `useCreateCompute()` 觸發計算，成功後關閉 modal（`useComputes` staleTime=0 自動 refetch）

**`components/computes/RouteListModal.tsx`**：
- `useComputeRoutes(computeId, computeStatus)` 取得路線（只在 `completed` 時 enabled）
- 每條路線一個 section：header 顯示車牌、車名、總距離（公里）、總時間（h:m）、總載重
- Stops table：`arrival_time`（分鐘）格式化為 `HH:mm`，停靠點按 `sequence` 排序

### 4. routeTree 問題

`routeTree.gen.ts` 是 TanStack Router Vite plugin 自動生成的，但 `pnpm build` 的腳本是 `tsc -b && vite build`，tsc 先跑時看到的是舊版 routeTree（不含 orders / computes），導致型別錯誤。

手動更新 `routeTree.gen.ts` 加入兩個新路由後，`pnpm build` 執行時 Vite plugin 同步將其正式重新生成，問題解決。

---

## 遇到的問題

**`search: {}` 型別不符**

`ComputesView` 的清除篩選按鈕導航到 `/computes` 時，`navigate({ to: '/computes', search: {} })` 報型別錯誤：TanStack Router 推導出 search 物件應符合 `{ orderId?: string }`，傳空物件不合。

解法：改為 `search: { orderId: undefined }`，明確表達「清除」語意，型別通過。

---

## 接下來的目標

- [ ] `info_between_two_point` 填充機制：地點建立後自動計算距離矩陣（串接地圖 API）
- [ ] 計算狀態輪詢：`useComputes` 目前 staleTime=0 但沒有主動輪詢，pending/computing 的計算任務需要手動重新整理才能看到更新 → 考慮對列表也加 `refetchInterval`
- [ ] `destination_snapshot` / `vehicle_snapshot` 格式規範化
- [ ] 本地端 E2E 測試（`local_dev.py` + `wrangler dev` + webhook 流程）
- [ ] `ORTOOLS_WEBHOOK_SECRET` 正式環境設定

---