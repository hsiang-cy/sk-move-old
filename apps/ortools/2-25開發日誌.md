# 2025-02-25 開發日誌

## 今日完成項目

### 1. v2 補丁：Feature 6 — 車輛與地點匹配限制

**問題**：原本所有車輛都可以造訪任何地點，無法表達「冷藏車才能去生鮮配送點」這類場景。

**改動檔案**：

- `src/vrp/models/schema_v2.py`
  新增 `LocationV2.allowed_vehicle_ids: list[int] | None = None`
  `None` = 所有車皆可造訪（向下相容 v1/v2 原有行為）
  `set` = 只有 id 在清單中的車輛可造訪此地點

- `src/vrp/solvers/ortools_v2/constraints.py`
  新增 `add_vehicle_constraints(routing, manager, data)`

- `src/vrp/solvers/ortools_v2/engine.py`
  在 `add_max_duration` 後加入 `add_vehicle_constraints` 呼叫

**關鍵 Bug 發現與修復**（見下方）

---

### 2. 計算耗時回傳（v1 + v2）

**問題**：使用者收到 webhook 結果時不知道此次計算花了多久。

**為何不用 FastAPI Middleware**：
Middleware 計時範圍是「收到請求 → 回傳 202」，這段時間幾乎是 0（只有 schema 驗證 + spawn）。
實際的 OR-Tools 求解發生在 Modal/asyncio 背景任務，Middleware 完全看不到這段。
正確的計時位置是 `solve_vrp_logic()` / `solve_vrp_v2_logic()` 內部。

**改動**：
- `src/vrp/solvers/ortools/engine.py` — 加入 `time.perf_counter()` 計時
- `src/vrp/solvers/ortools_v2/engine.py` — 同上

**回傳格式**（成功與失敗皆含此欄位）：
```json
{ "compute_id": 1, "elapsed_seconds": 2.847, "status": "success", ... }
```

---

## 測試結果（curl → webhook.site）

| compute_id | 端點 | 目的 | 結果 |
|---|---|---|---|
| 302 | v2 | `allowed_vehicle_ids` 約束驗證 | ✅ vehicle 1 → 巷弄客戶, vehicle 2 → 工廠 |
| 303 | v1 | 7 地點基準 | ✅ |
| 304 | v2 | 同 303 資料，無 v2 功能 | ✅ 路線完全相同，確認向下相容 |
| 305 | v2 | 全功能同時啟用 | ⚠️ 發現 Bug（見下方）|
| 301 | v1 | 確認 elapsed_seconds | ❌ Server 未重啟，舊版程式碼，elapsed 未出現 |

**305 測試分析**：
- `unserved_locations: [遠方客戶]` → **正確行為**
  - Vehicle 1（max_duration=40）：倉庫→遠方需 20+5+20=45min > 40min ❌
  - Vehicle 2（capacity=20）：已有 8+5+5=18，再加遠方(5)=23 > 20 ❌
  - 兩台車皆無法帶遠方客戶，跳過是正確的
- vehicle 2 造訪了只允許 vehicle 1 的「巷弄客戶」→ **Bug**（見下方）

---

## Bug：`VehicleVar.RemoveValue()` 在複合約束下被繞過

**現象**：
Test 302（無 AddDisjunction、無 soft TW、無 max_duration）：vehicle constraint 正確執行。
Test 305（三個 v2 功能同時啟用）：solver 無視 `RemoveValue`，把受限地點分給了不允許的車輛。

**根本原因**：
302 能「通過」是因為 capacity 本來就迫使 solver 用兩台車，VehicleVar constraint 只是碰巧和最優解吻合，沒有真正被考驗。305 中 vehicle 2 capacity=20 能獨自承擔所有地點（8+5+5=18 ≤ 20），constraint 是唯一阻力。
`RemoveValue()` 直接修改 IntVar 的 domain，在 OR-Tools routing 的 GLS 搜尋加上 `AddDisjunction`、soft TW、`SetMax` 多重約束共存時，傳播不保證被強制執行。

**修復**：
```python
# 修復前（不可靠）
vehicle_var = routing.VehicleVar(node_index)
vehicle_var.RemoveValue(v_idx)

# 修復後（透過 CP Solver 正式約束機制，一定執行）
solver = routing.solver()
solver.Add(routing.VehicleVar(node_index) != v_idx)
```

`routing.solver().Add()` 走的是 CP propagation engine，是 OR-Tools 用來加入正式約束的標準方式，與 dimension、disjunction 的優先順序對等，不會被繞過。

---

## 待完成

- [ ] 重啟 server，重跑 301（確認 `elapsed_seconds`）、305（確認 vehicle constraint 修復後正確）
- [ ] 更新 `src/vrp/solvers/ortools_v2/開發說明.md`，補充此 Bug 的說明
