# 開發日誌

---

## Day 1 — 2026-02-24

### 目標

讓後端（`apps/api`）能夠串接演算法服務（`apps/ortools`），完成「使用者觸發計算 → 演算法求解 → 結果寫回資料庫」的完整非同步流程。

---

### 規劃

#### 串接方式評估：GraphQL vs REST

演算法服務已經是 REST（`POST /vrp/solve`），所以「API → OR-Tools」這段沒有選擇空間，直接用 `fetch`。唯一需要決定的是 OR-Tools 把結果推回來的 **webhook receiver** 要用哪種協議。

結論選 **REST**，理由：
- OR-Tools 端只是單純 `httpx.post(url, json=payload)`，若用 GraphQL 需要讓 Python 端構造 mutation 字串，毫無意義
- Webhook 是 server-to-server，驗證用 shared secret header 最自然
- Hono 加一條 route 極輕量

#### 身份識別問題

OR-Tools 原本自己產生 UUID 作為 `job_id`，但 API 端並不知道這個 UUID，導致 webhook 回呼時無法對應到資料庫的 compute 記錄。

規劃改為**以後端為主**：由後端建立 compute 記錄後，把 `compute_id`（整數）帶入請求 body，OR-Tools 全程使用這個 ID，webhook payload 也回傳 `compute_id`，兩端以同一個整數 ID 對應。

#### 矩陣來源

距離矩陣與時間矩陣從資料庫的 `info_between_two_point` 表動態查詢，以 destination ID 為 key 組成 N×N 矩陣。若資料不完整則直接將 compute 標記為 `failed`。

---

### 執行過程

#### 1. OR-Tools 端改用 `compute_id`

- `vrp/schema.py`：`VRPRequest` 新增 `compute_id: int`
- `vrp/router.py`：移除 `import uuid` 與 UUID 生成，改從 request body 讀取
- `vrp/solver.py`：函式簽名 `job_id: str` → `compute_id: int`，webhook payload key 同步更新
- `main.py` / `local_dev.py`：同步更新

#### 2. 後端新增環境變數

`Context.env` 與 `Bindings` 加入：
- `ORTOOLS_URL` — 演算法服務的 base URL
- `API_BASE_URL` — API 自己的 URL（用於組 webhook_url）
- `ORTOOLS_WEBHOOK_SECRET?` — 可選的 shared secret（optional，避免破壞型別相容）

#### 3. 更新 `createCompute` resolver

流程：
1. 建立 compute 記錄，初始狀態 `pending`
2. 讀取 order 的 `destination_snapshot` / `vehicle_snapshot`
3. 以 destination ID 查 `info_between_two_point`，組 N×N 距離/時間矩陣
4. 組裝 `VRPRequest` payload（含 `compute_id`、`webhook_url`）
5. `await fetch` POST 到 OR-Tools（只等 202 確認，不等計算完成）
6. 任何失敗點都把 compute 標記為 `failed` 並附上原因

#### 4. 新增 `POST /internal/vrp-callback`

新增 `src/routes/webhook.ts`，接收 OR-Tools 的非同步回呼：
- 驗證 `X-Webhook-Secret`（若有設定）
- `status: error` → 更新 `compute_status = failed`，寫入 `fail_reason`
- `status: success` → 逐 route 寫入 `route` 表，再批次寫入 `route_stop`，最後更新 `compute_status = completed`

---

### 遇到的問題

**TypeScript 型別衝突**

`index.ts` 的 `Bindings` 包含 `ORTOOLS_WEBHOOK_SECRET: string`（必填），但 `context.ts` 的 `Context.env` 沒有這個欄位。GraphQL Yoga 在型別推導時要求兩者相容，導致 tsc 報錯。

解法：`ORTOOLS_WEBHOOK_SECRET` 改為 optional（`ORTOOLS_WEBHOOK_SECRET?: string`），符合「不設定也能運作」的業務語意，型別問題同時解決。

---

### 接下來的目標

- [ ] 前端串接：`createCompute` mutation 呼叫，顯示計算狀態（pending → completed）
- [ ] `info_between_two_point` 資料的填充機制：地點建立後如何自動計算並寫入距離矩陣（串接地圖 API）
- [ ] `destination_snapshot` / `vehicle_snapshot` 的格式規範化：目前依賴 client 傳入正確欄位，考慮在 `createOrder` resolver 側做資料正規化
- [ ] 本地端對 webhook 流程做完整 E2E 測試（`local_dev.py` + `wrangler dev`）
- [ ] `ORTOOLS_WEBHOOK_SECRET` 正式環境設定（`wrangler secret put`）
