目前不支援的場景

- [ ] 1. 多倉庫（最常見需求）

所有車輛固定從同一個 depot_index 出發並返回，無法讓不同車輛從不同起點出發或到不同終點結束。

- [ ] 2. 配對式取送（Pickup-and-Delivery Pairs）

目前的裝卸是「節點屬性」，不是「配對約束」。
現在的模型：A點有 delivery=5 就是在A卸5單位，沒有強制「先去B取、再去A送」的順序。
真實場景：快遞「從客戶A取件→送到客戶B」這種配對，目前不支援。

- [x] 3. 軟性時間窗（Soft Time Window）

目前時間窗是硬性約束：只要任一地點的時間窗無法滿足，整個求解直接失敗報錯，而不是允許遲到但加罰款繼續
找解。

- [x] 4. 可選地點（Optional Stops）

沒有用 AddDisjunction，所有地點必須全部造訪。
真實場景：「盡量多送，送不完的明天再說」這種情境不支援。

- [x] 5. 每台車的路線上限（Max Route Duration / Distance）

目前沒有限制「單一車輛最長行駛時間或距離」的維度，無法表達「司機最多工作8小時」。

- [x] 6. 車輛與地點的匹配限制

沒有技能/車型相容性約束，例如「冷藏車才能去生鮮配送點」。

---

# 實作計畫

## 階段一：v2 補丁 — 功能 6（車輛與地點匹配）

**策略：直接修改 v2，純 additive，不破壞任何現有行為。**

### Schema 變更（`src/vrp/models/schema_v2.py`）

在 `LocationV2` 新增一個欄位：

```python
allowed_vehicle_ids: list[int] | None = None
# None = 所有車都可以造訪（v1/v2 原有行為）
# set  = 只有列表中 id 的車輛可以造訪此地點
```

### 新增約束函式（`src/vrp/solvers/ortools_v2/constraints.py`）

新增 `add_vehicle_constraints(routing, manager, data: VRPRequestV2)`：

```python
# 建立 vehicle.id → vehicle index 的對照表
# 對每個有 allowed_vehicle_ids 的地點：
#   計算禁止造訪的車輛 index 集合
#   routing.VehicleVar(node_index).RemoveValue(forbidden_vehicle_idx)
```

`VehicleVar(node_index)` 代表「哪台車會造訪此節點」，直接移除不允許的值即可，OR-Tools 不需要額外 dimension。

### 呼叫位置（`src/vrp/solvers/ortools_v2/engine.py`）

在 `add_capacity_dimension` 之後、`SolveWithParameters` 之前加入：

```python
add_vehicle_constraints(routing, manager, data)
```

**捨棄：無。**

---

## 階段二：v3 — 功能 1（多倉庫）＋ 功能 2（配對式取送）

**策略：新建 v3，不繼承 `VRPRequest` 根類別，徹底移除 `depot_index`。**

功能 1 與功能 2 必須一起實作，因為它們都需要重構 `RoutingIndexManager` 的初始化方式，分開做會造成兩次破壞性改動。

---

### 必須捨棄的東西

| 現有設計 | v3 捨棄原因 | v3 替代方案 |
|---|---|---|
| `VRPRequest.depot_index: int` | 全域單一 depot 的概念消失 | 改為 `VehicleV3.start_location_index` / `end_location_index` |
| `RoutingIndexManager(N, V, depot_index)` | 不支援多起終點 | `RoutingIndexManager(N, V, starts, ends)` |
| `VRPRequestV3` 繼承自 `VRPRequest` | 繼承會帶入 `depot_index` 造成語意混亂 | `VRPRequestV3` 直接繼承 `pydantic.BaseModel` |

`Location.pickup` / `Location.delivery` **保留**，代表「該節點的獨立裝卸需求」，與 `DeliveryPair` 並存不衝突。

---

### 新增檔案結構

```
src/vrp/
├── models/
│   └── schema_v3.py          ← 新建
├── api/
│   └── router_v3.py          ← 新建（POST /vrp/v3/solve）
└── solvers/
    └── ortools_v3/
        ├── __init__.py        ← 新建
        ├── engine.py          ← 新建
        ├── constraints.py     ← 新建（含所有 v2 約束 + 2 個新約束）
        └── result.py          ← 新建（多起終點的路線解析）
```

同時更新 `src/main.py` 與 `src/local_dev.py`。

---

### Schema（`schema_v3.py`）

```python
class DeliveryPair(BaseModel):
    pickup_location_index: int    # locations 陣列的 index
    delivery_location_index: int  # locations 陣列的 index
    quantity: int                 # 此配對的貨量（用於容量計算）

class LocationV3(LocationV2):
    pass  # 繼承 v2 全部欄位：unserved_penalty, late_penalty, allowed_vehicle_ids

class VehicleV3(VehicleV2):
    start_location_index: int = 0   # 出發倉庫（locations 陣列的 index）
    end_location_index: int = 0     # 返回倉庫（可與 start 不同）
    # 繼承 v2：max_duration_minutes, fixed_cost, capacity

class VRPRequestV3(BaseModel):      # 不繼承任何 VRPRequest，重新宣告
    compute_id: int
    webhook_url: str
    locations: list[LocationV3]
    vehicles: list[VehicleV3]
    pairs: list[DeliveryPair] = []  # 空列表 = 無配對約束（向下相容）
    distance_matrix: list[list[int]]
    time_matrix: list[list[int]]
    time_limit_seconds: int = 30
    # 同 v1 的 field_validator：locations ≥ 2、vehicles ≥ 1、矩陣為 N×N
```

`pairs = []` 預設為空，代表 v3 可直接接受 v1/v2 格式的 payload（補上 `start_location_index` / `end_location_index` 欄位後）。

---

### OR-Tools 核心變更（`constraints.py`）

**`RoutingIndexManager` 初始化（在 `engine.py`）：**

```python
starts = [v.start_location_index for v in data.vehicles]
ends   = [v.end_location_index   for v in data.vehicles]
manager = pywrapcp.RoutingIndexManager(len(data.locations), len(data.vehicles), starts, ends)
```

**沿用自 v2 的約束（直接複製，型別改為 `VRPRequestV3`）：**
- `add_distance_cost`
- `add_fixed_costs`
- `add_capacity_dimension`（需調整：P&D pairs 的 quantity 也要納入容量計算）
- `add_time_dimension_v2`（改名為 `add_time_dimension`）
- `add_optional_stops`
- `add_max_duration`
- `add_vehicle_constraints`（從階段一移植）

**新增：`add_pickup_delivery_pairs(routing, manager, data, time_dimension)`：**

```python
for pair in data.pairs:
    pickup_idx   = manager.NodeToIndex(pair.pickup_location_index)
    delivery_idx = manager.NodeToIndex(pair.delivery_location_index)

    # 1. 兩點必須同一台車、取件必須在送件之前
    routing.AddPickupAndDelivery(pickup_idx, delivery_idx)

    # 2. 強制同一台車（AddPickupAndDelivery 本身已包含，這行是明確宣告）
    routing.solver().Add(
        routing.VehicleVar(pickup_idx) == routing.VehicleVar(delivery_idx)
    )

    # 3. 時間維度：取件時間 ≤ 送件時間
    routing.solver().Add(
        time_dimension.CumulVar(pickup_idx) <= time_dimension.CumulVar(delivery_idx)
    )
```

---

### Result 解析變更（`result.py`）

目前 v1/v2 的路線解析用全域 `depot_index` 識別起終點，v3 需改為從每台車自己的 start/end 取得：

```python
# v1/v2（舊）
if routing.IsEnd(solution.Value(routing.NextVar(index))):
    continue  # 空路線判斷：從 depot 直接回 depot

# v3（新）
start_node = data.vehicles[vehicle_id].start_location_index
# 空路線判斷邏輯相同，但路線的第一個 stop 不再固定是 locations[0]
```

Webhook payload 新增 `pairs_served` 統計（已完成的配對數量）。

---

### 實作順序

1. `schema_v3.py`（定義資料結構，其他都依賴它）
2. `solvers/ortools_v3/constraints.py`
3. `solvers/ortools_v3/result.py`
4. `solvers/ortools_v3/engine.py`
5. `api/router_v3.py`
6. 更新 `main.py`、`local_dev.py`
7. 更新本文件打勾

---

### Webhook Payload（v3 新增欄位）

```json
{
  "compute_id": 1,
  "status": "success",
  "total_distance": 4000,
  "routes": [...],
  "unserved_locations": [],
  "pairs_served": 3
}
```
