# apps/web — 專案開發歷程

本文件記錄 `apps/web`（React SPA）從零開始到現在的決策脈絡，供後續接手人員理解為何現在長這樣。

---

## 背景

前端從一開始就定位為 SPA（Single Page Application），對接 `apps/api` 的 GraphQL API。核心業務是讓使用者管理「配送地點、車輛」，建立「訂單」，觸發「路線最佳化計算」，並查看結果。

---

## 階段一：Vue 3 原型（2026-02-20）

**commit:** `first commit` (fa30571)

第一版用 **Vue 3** 開發：
- Vue Router（手動設定 `src/router/index.ts`）
- Pinia（狀態管理：`stores/locations.ts`、`stores/vehicles.ts`、`stores/vehicleTypes.ts`）
- 已完成頁面：Login、Locations（地點管理）、Vehicles（車輛管理）、VehicleTypes（車型管理）
- UI：Tailwind CSS + 自定義元件，包含 `MapBackground.vue`（地圖背景動畫）、`AuroraBackground.vue`

這個版本完整可用，三個 CRUD 頁面都有 Modal 表單。

---

## 階段二：Vue → React 遷移（2026-02-22）

**commit:** `[web] vue -> react` (f9a7ed7)

### 為何遷移

這次遷移發生在專案第三天，決策較倉促，但有幾個考量：

1. **生態系配合**：計劃引入 TanStack Router（file-based routing）和 TanStack Query（server state management），這兩個工具在 React 生態有更好的支援和文件
2. **型別安全路由**：TanStack Router 的 file-based routing 加上自動生成的 `routeTree.gen.ts`，路由型別是全程 TypeScript 強型別，相比 Vue Router 手動設定更不容易出錯
3. **Server State 分離**：TanStack Query 明確區分 server state（API 資料）和 client state（Zustand），比 Pinia 把兩者混在一起更清晰

### 遷移範圍

**一次性大爆炸遷移**（不是漸進式），原因是原本的 Vue 元件量不多（Login + 3 個 CRUD 頁面），全部重寫成本可控。

遷移完成後的技術棧：
- **React 19** + TypeScript
- **TanStack Router**（file-based，`src/routes/` 目錄）
- **TanStack Query**（所有 API 呼叫，`src/hooks/` 目錄）
- **Zustand**（只用於 auth token 持久化）
- **Tailwind CSS v4 + DaisyUI**（UI framework）
- **Vite**

### 架構決策：hooks vs stores

Vue 版把 API 呼叫放在 Pinia store（`stores/locations.ts` 等），React 版改為：
- `src/hooks/useLocations.ts`、`useVehicles.ts`… — TanStack Query hook，管理 fetch/cache/refetch
- `src/services/locations.ts`… — 純 GraphQL query/mutation 定義（字串）
- `src/stores/auth.ts` — 只剩 JWT token 的 localStorage 持久化

### `routeTree.gen.ts` 的陷阱

TanStack Router Vite plugin 在 dev server 啟動時自動生成 `routeTree.gen.ts`。但 `pnpm build` 的腳本是 `tsc -b && vite build`，**tsc 先跑**時讀到的是舊版（或缺少新路由的）`routeTree.gen.ts`，導致型別錯誤。

解法：手動更新 `routeTree.gen.ts` 後再執行 build。日後新增路由時記住這個限制。

### 認證路由結構

`_auth.tsx` 是認證 layout wrapper（protected route）。所有需要登入的頁面都命名為 `_auth.<pagename>.tsx`，由 `_auth.tsx` 統一攔截未登入跳轉。

---

## 階段三：E2E 登入流程完善（2026-02-22）

**commit:** `[web] e2e` (254c20c)

登入頁面（`LoginView.tsx`）補齊：
- 呼叫 `login` GraphQL mutation
- 成功後將 JWT 存入 Zustand store（持久化到 `localStorage`）
- 錯誤處理（帳密錯誤等）
- `services/api.ts` 的 `gql()` helper：自動從 localStorage 讀取 token 加入 `Authorization: Bearer` header；收到 `Unauthorized` 錯誤時自動跳轉 `/login`

---

## 階段四：Orders 頁面 — 嘗試 Kiro AI（2026-02-24）

**commit:** `[web] try kiro` (5b9ea67)

### 背景

到這個階段後端（API + OR-Tools）的串接剛完成，需要快速建立 Orders 和 Computes 的前端頁面。嘗試使用 **Kiro**（AWS 的 AI 程式碼助理）自動生成。

### Kiro 生成的內容

Kiro 根據需求文件（`.kiro/specs/frontend-order-compute-integration/`）生成了：
- `services/orders.ts` — Orders GraphQL 查詢
- `services/computes.ts` — Computes GraphQL 查詢
- `views/OrdersView.tsx` — 訂單列表頁
- `components/orders/OrderFormModal.tsx` — 建立訂單 Modal
- `components/orders/OrderDetailModal.tsx` — 訂單詳情 Modal
- `components/computes/ComputeStatusBadge.tsx` — 狀態 badge
- `hooks/useOrders.ts`、`hooks/useComputes.ts`
- `src/services/__verification__.md` — Kiro 的 process artifact（不應提交進 repo）

### 問題

Kiro 生成的代碼有幾個問題：
1. `goToComputes()` 是空殼（只有 `console.log`）
2. `formatTimestamp` 在兩個元件中各自重複定義
3. `services/orders.ts` 有 `type ApiOrder = Order` 這種無意義 type alias
4. `OrdersView.tsx` import 了 `useLocations` / `useVehicles`，但這兩個 hook 只在 form modal 內部用，不應由 View 層持有
5. Computes 頁面完全缺失

---

## 階段五：Claude 修復 + Computes 頁面（2026-02-24）

**commit:** `[web] use claude to fix` (a2335d0)

詳細決策過程記錄在根目錄 `開發日誌.md` Day 2。

### 清理 Kiro 遺留

- 刪除 `services/__verification__.md`
- `src/lib/utils.ts` 新增 `formatTimestamp(timestamp, options?)` — 統一 Unix timestamp → `zh-TW` 格式字串
- 修復 `OrderDetailModal.tsx` 的 `goToComputes()`：實作為 `navigate({ to: '/computes', search: { orderId: order.id } })`
- 刪除無用 type alias
- 移除 Kiro 的 spec 資料夾（`.kiro/`）

### Computes 頁面設計決策

**路線結果呈現**：純列表（每條路線一個 section + stops table），不做地圖視覺化（MVP 不需要，地圖需要額外 key + 費用）。

**導航設計**：
- Sidebar 新增獨立入口（`/computes`）
- 訂單列表可「前往計算」帶 `orderId` query param 跳轉並自動篩選

**search param 驗證**：使用 TanStack Router 原生 plain function validator（不引入 zod，避免增加依賴）。

### search param 型別問題

清除篩選按鈕 `navigate({ to: '/computes', search: {} })` 型別報錯，因為 TanStack Router 推導 search 應為 `{ orderId?: string }`。解法：改為 `search: { orderId: undefined }`，明確語意。

### 新建四個檔案

- `routes/_auth.computes.tsx` — 路由定義，解析可選 `orderId` query param
- `views/ComputesView.tsx` — 列表頁，pending/computing 有 loading dots，failed 有 tooltip 顯示原因
- `components/computes/ComputeFormModal.tsx` — 觸發計算（有 orderId 預選時自動填入）
- `components/computes/RouteListModal.tsx` — 路線詳情（stops 按 sequence 排序，時間格式化為 HH:mm）

---

## 架構現狀摘要

```
apps/web/src/
├── routes/
│   ├── __root.tsx            # root layout
│   ├── _auth.tsx             # 認證 wrapper（保護路由）
│   ├── login.tsx
│   ├── _auth.locations.tsx
│   ├── _auth.vehicles.tsx
│   ├── _auth.vehicle-types.tsx
│   ├── _auth.orders.tsx
│   └── _auth.computes.tsx
├── views/                    # page-level 元件
├── components/               # 按 domain 分資料夾
├── hooks/                    # TanStack Query hooks（server state）
├── services/                 # GraphQL query/mutation 定義
├── stores/
│   └── auth.ts               # Zustand：只存 JWT token
├── lib/
│   └── utils.ts              # formatTimestamp 等共用工具
└── routeTree.gen.ts          # 自動生成，不要手動編輯（build 時可能需要例外）
```

---

## 未完成事項（截至 2026-02-24）

- 計算狀態輪詢：`useComputes` 目前 staleTime=0 但沒有主動輪詢，pending/computing 的任務需要手動重新整理才能看到更新（需加 `refetchInterval`）
- `info_between_two_point` 填充機制的前端呈現（API 端已完成 Google Routes 整合）
- 更細緻的錯誤處理（目前大多 `console.error`）
